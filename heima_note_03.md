# Part3 引用
- 作用：给变量取个别名
- 语法：`数据类型 &别名 = 原名`
- 声明时必须初始化。别名不可以悬空，必须有 `= 原名` 这部分
- 定义别名之后，通过原名和别名都可以操作这个变量 / 访问这块内存空间

```cpp
int a = 10;

int &b;  // 错误
int &b = a;

int c = 20;
int &b = c;  // 错误
b = c;  // 赋值操作，不是更改引用：把 c 的值赋给 b，也就是赋给 a
```

## 引用的注意事项
- `&` 在此不是求地址运算，而是起标识作用。
- 引用 **在声明时就必须对它进行初始化**
- 引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。`ra=1;` 等价于 `a=1;` 
- 引用本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：**对引用求地址，就是对目标变量求地址。`&ra` 与 `&a` 相等。**
- 不能为数组建立引用，因为数组是由若干个元素组成，所以不能建立数组的别名

<br>

# 1. 引用作为函数参数
- 作用：函数传参时，让形参 “修饰” 实参  
- 优点：简化利用指针修改实参

例：交换函数：
### 1. 值传递
```cpp
void swap01(int a, int b)  // 传入 a 和 b 的值
{
    int temp = a;
    a = b;
    b = temp;

    cout << "swap01 a= " << a << endl;  //swap01 a = 20
    cout << "swap01 b= " << b << endl;  //swap01 b = 10
}
```
### 2. 地址传递
```cpp
void swap02(int * pa, int * pb)  // 传入数据的指针 pa 和 pb
{
    int temp = *pa;  // 取出 pa 所指地址的值，暂存
    *pa = *pb;  // 取出 pb 所指地址的值，覆盖到 pa 所指地址
    *pb = temp;  // 把之前暂存的值覆盖到 pb 所指地址
}
```
### 3. 引用传递
```cpp
void swap03(int & ra, int & rb)
{
    int temp = ra;
    ra = rb;
    rb = temp;
}
```
### 主函数调用
```cpp
int main()
{
    int a = 10;
    int b = 20;

    swap01(a, b);  //——> swap01 a = 20, swap01 b = 10
    cout << "a = " << a << endl;  //a = 10
    cout << "b = " << b << endl;  //b = 20
    // 值传递不影响函数外的实参

    swap02(&a, &b);  // & 取地址，把实参地址传给函数
    cout << "a = " << a << endl;  //a = 20
    cout << "b = " << b << endl;  //b = 10
    // 地址传递会修改实参

    swap03(a, b);  // int &ra = a; int &rb = b
    cout << "a = " << a << endl;  //a = 20
    cout << "b = " << b << endl;  //b = 10
    // 引用传递会修改实参

    return 0;
}
```
- main 函数和三个 swap 函数都是独立的局部空间，实参是在 main 函数的空间定义的。因为我们是在 main 函数中分别调用三个 swap 函数的，方便起见，以下我们把 main 函数的空间称为 “外面”，把 swap 函数的空间称为 “里面”
- **值传递：** main 空间的实参和 swap1 空间的形参没有产生任何连接。外面的实参 a、b 通过函数把值 “赋给” 里面的形参去参与 swap1 空间内的运算。所以相当于在 swap1 的空间里开辟两个局部变量作为外部实参的副本。而交换的操作只发生在 swap1 空间里，所以只有 swap1 空间下的形参 a 、b 被交换了数值，外面 main 函数空间里的实参 a 、b 保持原样。
- **地址传递：** swap2 函数接收到的是 main 空间中实参的地址（指针），所以 swap2 空间里做的事就是透过传入的指针去访问外面 main 空间的实参，因此 main 空间里的实参被 swap2 空间里的函数体修改了
- **引用传递：** 函数把自己内部使用的局部变量（形参）定义成了对外部传入参数（实参）的别名，也就是说，让形参 “再次命名” 实参所在的内存空间。所以函数体内部对形参的操作，实际上是透过这块内存的 “别名” 操作了外面的实参。

当引用作为一个函数形参时，它所引用的变量的生命周期必须保证在函数的执行期间内是有效的。在函数执行期间内，对于引用所指向的变量所进行的任何修改都将影响到函数调用方式中的原始变量。

当函数返回后，引用所指向的变量仍然存在，因此可以继续访问它而不会报错。但是需要注意的是，如果引用所指向的变量是在函数中被销毁的局部变量，则在函数返回后访问该引用将会导致未定义的行为。

***

## 为什么需要引用

> 参考自 [知乎](https://zhuanlan.zhihu.com/p/282846275#:~:text=%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%95%E7%94%A8,C%2B%2B%E6%8F%90%E5%80%A1%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E3%80%82)

- 通过值传递，相当于创建副本，并不会改变原始的值。
- 通过地址传递，可以改变原始的值，本质还是值传递。
- 通过引用传递，操作的就是原始数据本身，所以会改变原始的值。引用传递减少了数值的赋值，提高效率。

假如传入的参数是一个庞大的结构体，内存消耗：值传递>地址传递>引用传递 

值传递造成的内存消耗是最高的，它在栈区把数据重新复制了一份给形参；地址传递次之，只需要开辟一小块内存空间存放结构体的地址；引用传递完全不造成额外的内存占用，它把自己直接绑定到实参

***

## 指针与引用的区别：
- 指针本身也要占用内存空间，它存放目标变量的地址；而引用只是别名，不占空间
- 指针是可以独立存在的; 但是引用不行
- 引用必须要进行初始化，指针没有必要
- 指针可以设置为NULL， 但是引用不行
- 引用一旦进行初始化之后，不会再改变其指向；但指针可以

# 2. 引用作为函数返回值
- ！注意：**不要返回局部变量的引用**
  > 类似：**不要返回局部变量的地址。**

- 用法：函数调用可以作为左值

## 不要返回局部变量的引用
eg
  ```cpp
  int & func()
  {
    int a = 10;
    // 这里 a 只是普通的声明，局部变量存放在栈区
    // func()函数 结束后，随着栈区释放，a 不存在
    return a;
  }

  int main()
  {
    int & ref = func();
    cout << ref << endl;  // 函数func()结束，局部变量a已被清空，但内容尚未被覆写
    cout << ref << endl;  // 栈区已经被覆写

    return 0;
  }
  ```
  输出
  ```
  10
  267955168
  ```

这里一样是结果不可预知。离开作用域，局部变量已经被释放，但该空间内的数据也许并未被覆盖（x86环境），从而照成依然出现正确的结果。但这种情况是不可预知的，在x64环境下甚至第一次输出已经是乱码。这种操作是非法的

eg
  ```cpp
  int & func()
  {
    static int a = 10; 
    // 这里把 a 定义为“静态”，它会存放在全局区。
    // func()函数 结束后，a 依然存在
    return a;
  }

  int main()
  {
    int & ref = func();
    cout << ref << endl; 
    cout << ref << endl; 
    cout << ref << endl;
    cout << ref << endl;

    return 0;
  }
  ```
  输出
  ```
  10
  10
  10
  10
  ```

## 用法：函数调用可以作为左值
eg
  ```cpp
  int & func()
  {
    static int a = 10; 
    // 这里把 a 定义为“静态”，它会存放在全局区。
    // func()函数 结束后，a 依然存在
    return a;
  }

  int main()
  {
    int & ref = func();
    cout << ref << endl; 
    cout << ref << endl; 

    func() = 1000；
    // 因为函数返回一个引用，相当于通过函数修改了内部 a 的值，再通过别名 ref 访问
    cout << ref << endl;
    cout << ref << endl;

    return 0;
  }
  ```
  输出
  ```
  10
  10
  1000
  1000
  ```
<br>
<br>

# 3. 引用的本质：指针常量

```cpp
int & ref = a;
cout << ref;
ref = 20;
```
```cpp
int * const ref = &a;
cout << *ref;
*ref = 20;
```
C++推荐使用引用。因为语法被简化，所有指针操作都由编译器代为完成

<br>

# 4. 常量引用
- 作用：常量引用修饰形参，防止误操作
- 在函数形参列表中，可以加const修饰形参，防止形参改变实参

eg
```cpp
void showValue(const int& val)
{
    //v+=10;  // error
    cout << "val = " << val << endl;
}

int main()
{   
    int a = 10;
    const int b = 20;
    int & ref = a;
    int & ref = b;  // error
    const int & ref = b;

    int & ref = 10; // error
    const int & ref = 10;

    ref = 20; // error

    int c = 100;
    showValue(c);
}
```

- 普通引用的右值只能是变量名。如果是数值或者常量，引用也需要被限定为常量引用
  - 否则就是一个非常量引用了一个常量。
  - 普通引用的特性是可被修改，但它指向的常量实际上不可被修改，产生了冲突
- 给常量引用重新赋值是非法的
- 函数输入的引用被限定为常量引用之后，就可以保护传入的实参处于只读状态，不会被意外修改