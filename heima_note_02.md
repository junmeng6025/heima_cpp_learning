# Part2 内存管理
# 1. 内存分区
- **代码区**：存放函数体的二进制代码，由操作系统管理
- **全局区 (static)**：存放全局变量、静态变量、常量
- **栈区 (stack)**：由编译器自动分配和释放，存放函数的参数、局部变量
- **堆区 (heap)**：由程序员分配和释放。若未手动释放，程序结束时由OS回收
  
> 意义：在不同区域存放数据，赋予不同的生命周期，提高代码运行效率  

指针变量在堆区  
普通变量在栈区

## 1.1 程序运行前
在编译之后，生成了 .exe 可执行程序。**未执行该程序前**分为两个区域
### **代码区：**
- 存放CPU执行的机器指令  
- 代码区是**共享**的，共享的目的是，对频繁被执行的程序只需要在内存中有一份代码即可  
- 代码区是**只读**的，防止被程序意外修改

### **全局区：**
- 该区域的数据在程序结束后由OS释放
- 存放着：
  - 全局变量
  - const 修饰的全局常量
  - 字符串常量
  - 静态变量

*** 
### *关于变量的解释*
- 局部变量：在函数体内部定义的变量。只能在该函数内被调用（作用域）
  > 其他函数访问不到当前函数内的局部变量  
  > 在其他函数内定义另一个同名的局部变量也不会冲突，例如 for 循环里的 i

- 全局变量：不在任何函数体内定义的变量。可以被任何函数共享使用 **-> 在全局区**
- 静态变量 static：**-> 在全局区**
  > 在普通变量前加上关键字 static

- 常量：
  - 字符串常量：代码里任何双引号的内容 **-> 在全局区**
  - const 修饰的常量
    - const 修饰的全局变量 **-> 在全局区**
    - const 修饰的局部变量 **-> 不存放在全局区**，和局部变量一样存放在栈区
***
## 1.2 程序运行后
执行 .exe 之后，会新开辟一个内存区，存放运行时产生的“临时数据”
### **栈区 stack** 
- 由编译器自动分配和释放，存放函数的参数值、局部变量
- 不会存在到程序运行结束。只要函数执行完就会被释放
- 形参也会被放在栈区
- ！注意：**不要返回局部变量的地址。** 栈区开辟的数据会被编译器自动释放
  > 当函数执行完，程序失去对栈区原来地址的控制权。这块地址可能会存放别的内容，输出内容变得不可控

  eg
  ```cpp
  int * func()
  {
    int a = 10;
    return &a;
  }

  int main()
  {
    int * p = func();
    cout << *p << endl;  // 函数func()结束，p已经失效，但内容尚未被覆写
    cout << *p << endl;  // p所指空间的内容已经被覆写

    return 0;
  }
  ```
  输出
  ```
  10
  267955168
  ```
  当func()执行完，函数事实上已经失去了对 p所指地址的控制权
  之所以第一次还能输出10，是因为这块内存还没有被覆盖  
  第二次输出的时候已经被别的数据覆盖了，所以这种方式输出的内容是不可控的

### **堆区 heap** 
- 由程序员分配和释放。如果程序员没有释放，程序结束时会被OS回收
- new 关键字会在堆区开辟内存，返回该变量的地址。所以声明变量时需要用一个指针接收

    eg
    ```cpp
    int * func()
    {
        int * ptr = new int(10);
        return ptr;
        // 或者直接 return new int(10);
    }

    int main()
    {
        int * p = func();  // p本身存放在栈区，p包含的地址指向的变量存在堆区
        cout << *p << endl;
        cout << *p << endl;
        cout << *p << endl;

        return 0;
    }
    ```
    输出
    ```
    10
    10
    10
    ```

## 1.3 new 操作符
- C++利用 `new` 操作符在堆区开辟数据。  
- 堆区由程序员手动开辟，手动释放。释放利用操作符 `delete`.  
- 利用 `new` 关键字创建的数据，会返回该数据的地址。所以需要一个相应类型的指针来接收

### 在堆区开辟一个普通整型变量
```cpp
int * func()
{
    return new int(10);  // 变量的值是10
}

/// 在堆区开辟一个普通整型变量
void test01()
{
    int * p = func();
    cout << *p << endl;  // 10
    cout << *p << endl;  // 10
    cout << *p << endl;  // 10
    // 都可以正常输出，因为p所指的内存在堆区。只要没有手动释放就一直存在

    delete p;  // 释放 p 所指的内存

    cout << *p << endl;  // 再次访问会报错，读取访问权限冲突
}
```
### 在堆区开辟一个数组
```cpp
/// 在堆区开辟一个数组
void test02()
{
   int * p_arr = new int[10];  // 数组元素个数是10，返回数组首地址
   for (int i = 0; i < 10; i++)
   {
       p_arr[i] = i + 100;
   }
   for (int i = 0; i < 10; i++)
   {
       cout << p_arr[i] << endl;
   }
   delete[] p_arr;  // 释放数组，记得加 []
}
```